var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  Stagehand: () => Stagehand
});
module.exports = __toCommonJS(lib_exports);
var import_test = require("@playwright/test");
var import_fs2 = __toESM(require("fs"));
var import_sdk2 = require("@browserbasehq/sdk");

// lib/prompt.ts
var actSystemPrompt = `
# Instructions
You are a browser automation assistant. Your job is to accomplish the user's goal across multiple model calls.

You are given:
1. the user's overall goal
2. the steps that you've taken so far
3. a list of active DOM elements in this chunk to consider to get closer to the goal. 
4. Optionally, a list of variable names that the user has provided that you may use to accomplish the goal. To use the variables, you must use the special <|VARIABLE_NAME|> syntax.

You have 2 tools that you can call: doAction, and skipSection. Do action only performs Playwright actions. Do not perform any other actions.

Note: If there is a popup on the page for cookies or advertising that has nothing to do with the goal, try to close it first before proceeding. As this can block the goal from being completed.

Also, verify if the goal has been accomplished already. Do this by checking if the goal has been accomplished based on the previous steps completed, the current page DOM elements and the current page URL / starting page URL. If it has, set completed to true and finish the task.

Do exactly what the user's goal is. Do not exceed the scope of the goal.
`;
var verifyActCompletionSystemPrompt = `
You are a browser automation assistant. The job has given you a goal and a list of steps that have been taken so far. Your job is to determine if the user's goal has been completed based on the provided information.

# Input
You will receive:
1. The user's goal: A clear description of what the user wants to achieve.
2. Steps taken so far: A list of actions that have been performed up to this point.
3. An image of the current page

# Your Task
Analyze the provided information to determine if the user's goal has been fully completed.

# Output
Return a boolean value:
- true: If the goal has been definitively completed based on the steps taken and the current page.
- false: If the goal has not been completed or if there's any uncertainty about its completion.

# Important Considerations
- False positives are okay. False negatives are not okay.
- Look for evidence of errors on the page or something having gone wrong in completing the goal. If one does not exist, return true.
`;
function buildVerifyActCompletionSystemPrompt() {
  return {
    role: "system",
    content: verifyActCompletionSystemPrompt
  };
}
function buildVerifyActCompletionUserPrompt(goal, steps = "None", domElements) {
  let actUserPrompt = `
# My Goal
${goal}

# Steps You've Taken So Far
${steps}
`;
  if (domElements) {
    actUserPrompt += `
# Active DOM Elements on the current page
${domElements}
`;
  }
  return {
    role: "user",
    content: actUserPrompt
  };
}
function buildActSystemPrompt() {
  return {
    role: "system",
    content: actSystemPrompt
  };
}
function buildActUserPrompt(action, steps = "None", domElements, variables) {
  let actUserPrompt = `
# My Goal
${action}

# Steps You've Taken So Far
${steps}

# Current Active Dom Elements
${domElements}
`;
  if (variables) {
    actUserPrompt += `
# Variables
${Object.entries(variables).map(([key, value]) => `<|${key.toUpperCase()}|>`).join("\n")}
`;
  }
  return {
    role: "user",
    content: actUserPrompt
  };
}
var actTools = [
  {
    type: "function",
    function: {
      name: "doAction",
      description: "execute the next playwright step that directly accomplishes the goal",
      parameters: {
        type: "object",
        required: ["method", "element", "args", "step", "completed"],
        properties: {
          method: {
            type: "string",
            description: "The playwright function to call."
          },
          element: {
            type: "number",
            description: "The element number to act on"
          },
          args: {
            type: "array",
            description: "The required arguments",
            items: {
              type: "string",
              description: "The argument to pass to the function"
            }
          },
          step: {
            type: "string",
            description: "human readable description of the step that is taken in the past tense. Please be very detailed."
          },
          why: {
            type: "string",
            description: "why is this step taken? how does it advance the goal?"
          },
          completed: {
            type: "boolean",
            description: "true if the goal should be accomplished after this step"
          }
        }
      }
    }
  },
  {
    type: "function",
    function: {
      name: "skipSection",
      description: "skips this area of the webpage because the current goal cannot be accomplished here",
      parameters: {
        type: "object",
        properties: {
          reason: {
            type: "string",
            description: "reason that no action is taken"
          }
        }
      }
    }
  }
];
var extractSystemPrompt = `You are extracting content on behalf of a user. You will be given:
1. An instruction
2. A list of DOM elements to extract from

Print the exact text from the DOM elements with all symbols, characters, and endlines as is.
Print null or an empty string if no new information is found.

ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.
`;
function buildExtractSystemPrompt() {
  const content = extractSystemPrompt.replace(/\s+/g, " ");
  return {
    role: "system",
    content
  };
}
function buildExtractUserPrompt(instruction, domElements) {
  return {
    role: "user",
    content: `Instruction: ${instruction}
DOM: ${domElements}

ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.`
  };
}
var refineSystemPrompt = `You are tasked with refining and filtering information for the final output based on newly extracted and previously extracted content. Your responsibilities are:
1. Remove exact duplicates for elements in arrays and objects.
2. For text fields, append or update relevant text if the new content is an extension, replacement, or continuation.
3. For non-text fields (e.g., numbers, booleans), update with new values if they differ.
4. Add any completely new fields or objects.

Return the updated content that includes both the previous content and the new, non-duplicate, or extended information.`;
function buildRefineSystemPrompt() {
  return {
    role: "system",
    content: refineSystemPrompt
  };
}
function buildRefineUserPrompt(instruction, previouslyExtractedContent, newlyExtractedContent) {
  return {
    role: "user",
    content: `Instruction: ${instruction}
Previously extracted content: ${JSON.stringify(previouslyExtractedContent, null, 2)}
Newly extracted content: ${JSON.stringify(newlyExtractedContent, null, 2)}
Refined content:`
  };
}
var metadataSystemPrompt = `You are an AI assistant tasked with evaluating the progress and completion status of an extraction task.
Analyze the extraction response and determine if the task is completed or if more information is needed.

Strictly abide by the following criteria:
1. Once the instruction has been satisfied by the current extraction response, ALWAYS set completion status to true and stop processing, regardless of remaining chunks.
2. Only set completion status to false if BOTH of these conditions are true:
   - The instruction has not been satisfied yet
   - There are still chunks left to process (chunksTotal > chunksSeen)`;
function buildMetadataSystemPrompt() {
  return {
    role: "system",
    content: metadataSystemPrompt
  };
}
function buildMetadataPrompt(instruction, extractionResponse, chunksSeen, chunksTotal) {
  return {
    role: "user",
    content: `Instruction: ${instruction}
Extracted content: ${JSON.stringify(extractionResponse, null, 2)}
chunksSeen: ${chunksSeen}
chunksTotal: ${chunksTotal}`
  };
}
var observeSystemPrompt = `
You are helping the user automate the browser by finding elements based on what the user wants to observe in the page.
You will be given:
1. a instruction of elements to observe
2. a numbered list of possible elements or an annotated image of the page

Return an array of elements that match the instruction.
`;
function buildObserveSystemPrompt() {
  const content = observeSystemPrompt.replace(/\s+/g, " ");
  return {
    role: "system",
    content
  };
}
function buildObserveUserMessage(instruction, domElements) {
  return {
    role: "user",
    content: `instruction: ${instruction}
DOM: ${domElements}`
  };
}

// lib/inference.ts
var import_zod = require("zod");

// lib/llm/LLMClient.ts
var modelsWithVision = [
  "gpt-4o",
  "gpt-4o-mini",
  "claude-3-5-sonnet-latest",
  "claude-3-5-sonnet-20240620",
  "claude-3-5-sonnet-20241022",
  "gpt-4o-2024-08-06"
];
var AnnotatedScreenshotText = "This is a screenshot of the current page state with the elements annotated on it. Each element id is annotated with a number to the top left of it. Duplicate annotations at the same location are under each other vertically.";

// lib/inference.ts
function verifyActCompletion(_0) {
  return __async(this, arguments, function* ({
    goal,
    steps,
    llmProvider,
    modelName,
    screenshot,
    domElements,
    logger,
    requestId
  }) {
    const llmClient = llmProvider.getClient(modelName, requestId);
    const messages = [
      buildVerifyActCompletionSystemPrompt(),
      buildVerifyActCompletionUserPrompt(goal, steps, domElements)
    ];
    const response = yield llmClient.createChatCompletion({
      model: modelName,
      messages,
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      image: screenshot ? {
        buffer: screenshot,
        description: "This is a screenshot of the whole visible page."
      } : void 0,
      response_model: {
        name: "Verification",
        schema: import_zod.z.object({
          completed: import_zod.z.boolean().describe("true if the goal is accomplished")
        })
      }
    });
    if (!response || typeof response !== "object") {
      logger({
        category: "VerifyAct",
        message: "Unexpected response format: " + JSON.stringify(response)
      });
      return false;
    }
    if (response.completed === void 0) {
      logger({
        category: "VerifyAct",
        message: "Missing 'completed' field in response"
      });
      return false;
    }
    return response.completed;
  });
}
function fillInVariables(text, variables) {
  let processedText = text;
  Object.entries(variables).forEach(([key, value]) => {
    const placeholder = `<|${key.toUpperCase()}|>`;
    processedText = processedText.replace(placeholder, value);
  });
  return processedText;
}
function act(_0) {
  return __async(this, arguments, function* ({
    action,
    domElements,
    steps,
    llmProvider,
    modelName,
    screenshot,
    retries = 0,
    logger,
    requestId,
    variables
  }) {
    const llmClient = llmProvider.getClient(modelName, requestId);
    const messages = [
      buildActSystemPrompt(),
      buildActUserPrompt(action, steps, domElements, variables)
    ];
    const response = yield llmClient.createChatCompletion({
      model: modelName,
      messages,
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      tool_choice: "auto",
      tools: actTools,
      image: screenshot ? { buffer: screenshot, description: AnnotatedScreenshotText } : void 0
    });
    const toolCalls = response.choices[0].message.tool_calls;
    if (toolCalls && toolCalls.length > 0) {
      if (toolCalls[0].function.name === "skipSection") {
        return null;
      }
      return JSON.parse(toolCalls[0].function.arguments);
    } else {
      if (retries >= 2) {
        logger({
          category: "Act",
          message: "No tool calls found in response"
        });
        return null;
      }
      return act({
        action,
        domElements,
        steps,
        llmProvider,
        modelName,
        retries: retries + 1,
        logger,
        requestId
      });
    }
  });
}
function extract(_0) {
  return __async(this, arguments, function* ({
    instruction,
    progress,
    previouslyExtractedContent,
    domElements,
    schema,
    llmProvider,
    modelName,
    chunksSeen,
    chunksTotal,
    requestId
  }) {
    const llmClient = llmProvider.getClient(modelName, requestId);
    const extractionResponse = yield llmClient.createChatCompletion({
      model: modelName,
      messages: [
        buildExtractSystemPrompt(),
        buildExtractUserPrompt(instruction, domElements)
      ],
      response_model: {
        schema,
        name: "Extraction"
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0
    });
    const refinedResponse = yield llmClient.createChatCompletion({
      model: modelName,
      messages: [
        buildRefineSystemPrompt(),
        buildRefineUserPrompt(
          instruction,
          previouslyExtractedContent,
          extractionResponse
        )
      ],
      response_model: {
        schema,
        name: "RefinedExtraction"
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0
    });
    const metadataSchema = import_zod.z.object({
      progress: import_zod.z.string().describe(
        "progress of what has been extracted so far, as concise as possible"
      ),
      completed: import_zod.z.boolean().describe(
        "true if the goal is now accomplished. Use this conservatively, only when you are sure that the goal has been completed."
      )
    });
    const metadataResponse = yield llmClient.createChatCompletion({
      model: modelName,
      messages: [
        buildMetadataSystemPrompt(),
        buildMetadataPrompt(
          instruction,
          refinedResponse,
          chunksSeen,
          chunksTotal
        )
      ],
      response_model: {
        name: "Metadata",
        schema: metadataSchema
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0
    });
    refinedResponse.metadata = metadataResponse;
    return refinedResponse;
  });
}
function observe(_0) {
  return __async(this, arguments, function* ({
    instruction,
    domElements,
    llmProvider,
    modelName,
    image,
    requestId
  }) {
    const observeSchema = import_zod.z.object({
      elements: import_zod.z.array(
        import_zod.z.object({
          elementId: import_zod.z.number().describe("the number of the element"),
          description: import_zod.z.string().describe(
            "a description of the element and what it is relevant for"
          )
        })
      ).describe("an array of elements that match the instruction")
    });
    const llmClient = llmProvider.getClient(modelName, requestId);
    const observationResponse = yield llmClient.createChatCompletion({
      model: modelName,
      messages: [
        buildObserveSystemPrompt(),
        buildObserveUserMessage(instruction, domElements)
      ],
      image: image ? { buffer: image, description: AnnotatedScreenshotText } : void 0,
      response_model: {
        schema: observeSchema,
        name: "Observation"
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0
    });
    if (!observationResponse) {
      throw new Error("no response when finding a selector");
    }
    return observationResponse;
  });
}

// lib/llm/OpenAIClient.ts
var import_openai = __toESM(require("openai"));
var import_zod2 = require("openai/helpers/zod");
var OpenAIClient = class {
  constructor(logger, enableCaching = false, cache, requestId) {
    this.client = new import_openai.default();
    this.logger = logger;
    this.requestId = requestId;
    this.cache = cache;
    this.enableCaching = enableCaching;
  }
  createChatCompletion(options) {
    return __async(this, null, function* () {
      const cacheOptions = {
        model: options.model,
        messages: options.messages,
        temperature: options.temperature,
        top_p: options.top_p,
        frequency_penalty: options.frequency_penalty,
        presence_penalty: options.presence_penalty,
        image: options.image,
        response_model: options.response_model
      };
      if (this.enableCaching) {
        const cachedResponse = yield this.cache.get(cacheOptions, this.requestId);
        if (cachedResponse) {
          this.logger({
            category: "llm_cache",
            message: `LLM Cache hit - returning cached response`,
            level: 1
          });
          return cachedResponse;
        } else {
          this.logger({
            category: "llm_cache",
            message: `LLM Cache miss - no cached response found`,
            level: 1
          });
        }
      }
      if (options.image) {
        const screenshotMessage = {
          role: "user",
          content: [
            {
              type: "image_url",
              image_url: {
                url: `data:image/jpeg;base64,${options.image.buffer.toString("base64")}`
              }
            },
            ...options.image.description ? [{ type: "text", text: options.image.description }] : []
          ]
        };
        options.messages = [...options.messages, screenshotMessage];
      }
      const _a = options, { image, response_model } = _a, openAiOptions = __objRest(_a, ["image", "response_model"]);
      let responseFormat = void 0;
      if (options.response_model) {
        responseFormat = (0, import_zod2.zodResponseFormat)(
          options.response_model.schema,
          options.response_model.name
        );
      }
      const response = yield this.client.chat.completions.create(__spreadProps(__spreadValues({}, openAiOptions), {
        response_format: responseFormat
      }));
      if (response_model) {
        const extractedData = response.choices[0].message.content;
        const parsedData = JSON.parse(extractedData);
        if (this.enableCaching) {
          this.cache.set(
            cacheOptions,
            __spreadValues({}, parsedData),
            this.requestId
          );
        }
        return __spreadValues({}, parsedData);
      }
      if (this.enableCaching) {
        this.cache.set(cacheOptions, response, this.requestId);
      }
      return response;
    });
  }
};

// lib/llm/AnthropicClient.ts
var import_sdk = __toESM(require("@anthropic-ai/sdk"));
var import_zod_to_json_schema = require("zod-to-json-schema");
var AnthropicClient = class {
  constructor(logger, enableCaching = false, cache, requestId) {
    this.client = new import_sdk.default({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    this.logger = logger;
    this.cache = cache;
    this.enableCaching = enableCaching;
    this.requestId = requestId;
  }
  createChatCompletion(options) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g;
      const cacheOptions = {
        model: options.model,
        messages: options.messages,
        temperature: options.temperature,
        image: options.image,
        response_model: options.response_model,
        tools: options.tools,
        retries: options.retries
      };
      if (this.enableCaching) {
        const cachedResponse = yield this.cache.get(cacheOptions, this.requestId);
        if (cachedResponse) {
          this.logger({
            category: "llm_cache",
            message: `LLM Cache hit - returning cached response`,
            level: 1
          });
          return cachedResponse;
        } else {
          this.logger({
            category: "llm_cache",
            message: `LLM Cache miss - no cached response found`,
            level: 1
          });
        }
      }
      const systemMessage = options.messages.find((msg) => msg.role === "system");
      const userMessages = options.messages.filter(
        (msg) => msg.role !== "system"
      );
      if (options.image) {
        const screenshotMessage = {
          role: "user",
          content: [
            {
              type: "image",
              source: {
                type: "base64",
                media_type: "image/jpeg",
                data: options.image.buffer.toString("base64")
              }
            },
            ...options.image.description ? [{ type: "text", text: options.image.description }] : []
          ]
        };
        options.messages = [...options.messages, screenshotMessage];
      }
      let anthropicTools = (_a = options.tools) == null ? void 0 : _a.map((tool) => {
        if (tool.type === "function") {
          return {
            name: tool.function.name,
            description: tool.function.description,
            input_schema: {
              type: "object",
              properties: tool.function.parameters.properties,
              required: tool.function.parameters.required
            }
          };
        }
        return tool;
      });
      let toolDefinition;
      if (options.response_model) {
        const jsonSchema = (0, import_zod_to_json_schema.zodToJsonSchema)(options.response_model.schema);
        const schemaProperties = ((_c = (_b = jsonSchema.definitions) == null ? void 0 : _b.MySchema) == null ? void 0 : _c.properties) || jsonSchema.properties;
        const schemaRequired = ((_e = (_d = jsonSchema.definitions) == null ? void 0 : _d.MySchema) == null ? void 0 : _e.required) || jsonSchema.required;
        toolDefinition = {
          name: "print_extracted_data",
          description: "Prints the extracted data based on the provided schema.",
          input_schema: {
            type: "object",
            properties: schemaProperties,
            required: schemaRequired
          }
        };
      }
      if (toolDefinition) {
        anthropicTools = anthropicTools != null ? anthropicTools : [];
        anthropicTools.push(toolDefinition);
      }
      const response = yield this.client.messages.create({
        model: options.model,
        max_tokens: options.max_tokens || 1500,
        messages: userMessages.map((msg) => ({
          role: msg.role,
          content: msg.content
        })),
        tools: anthropicTools,
        system: systemMessage == null ? void 0 : systemMessage.content,
        temperature: options.temperature
      });
      const transformedResponse = {
        id: response.id,
        object: "chat.completion",
        created: Date.now(),
        model: response.model,
        choices: [
          {
            index: 0,
            message: {
              role: "assistant",
              content: ((_f = response.content.find((c) => c.type === "text")) == null ? void 0 : _f.text) || null,
              tool_calls: response.content.filter((c) => c.type === "tool_use").map((toolUse) => ({
                id: toolUse.id,
                type: "function",
                function: {
                  name: toolUse.name,
                  arguments: JSON.stringify(toolUse.input)
                }
              }))
            },
            finish_reason: response.stop_reason
          }
        ],
        usage: {
          prompt_tokens: response.usage.input_tokens,
          completion_tokens: response.usage.output_tokens,
          total_tokens: response.usage.input_tokens + response.usage.output_tokens
        }
      };
      this.logger({
        category: "Anthropic",
        message: "Transformed response: " + JSON.stringify(transformedResponse)
      });
      if (options.response_model) {
        const toolUse = response.content.find((c) => c.type === "tool_use");
        if (toolUse && "input" in toolUse) {
          const result = toolUse.input;
          if (this.enableCaching) {
            this.cache.set(cacheOptions, result, this.requestId);
          }
          return result;
        } else {
          if (!options.retries || options.retries < 5) {
            return this.createChatCompletion(__spreadProps(__spreadValues({}, options), {
              retries: ((_g = options.retries) != null ? _g : 0) + 1
            }));
          }
          throw new Error(
            "Create Chat Completion Failed: No tool use with input in response"
          );
        }
      }
      if (this.enableCaching) {
        this.cache.set(cacheOptions, transformedResponse, this.requestId);
      }
      return transformedResponse;
    });
  }
};

// lib/cache/BaseCache.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var BaseCache = class {
  constructor(logger, cacheDir = path.join(process.cwd(), "tmp", ".cache"), cacheFile = "cache.json") {
    this.CACHE_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
    // 1 week in milliseconds
    this.CLEANUP_PROBABILITY = 0.01;
    this.LOCK_TIMEOUT_MS = 1e3;
    this.lockAcquired = false;
    this.lockAcquireFailures = 0;
    // Added for request ID tracking
    this.requestIdToUsedHashes = {};
    this.logger = logger;
    this.cacheDir = cacheDir;
    this.cacheFile = path.join(cacheDir, cacheFile);
    this.lockFile = path.join(cacheDir, "cache.lock");
    this.ensureCacheDirectory();
    this.setupProcessHandlers();
  }
  setupProcessHandlers() {
    const releaseLockAndExit = () => {
      this.releaseLock();
      process.exit();
    };
    process.on("exit", releaseLockAndExit);
    process.on("SIGINT", releaseLockAndExit);
    process.on("SIGTERM", releaseLockAndExit);
    process.on("uncaughtException", (err) => {
      this.logger({
        category: "base_cache",
        message: `Uncaught exception: ${err}`,
        level: 2
      });
      if (this.lockAcquired) {
        releaseLockAndExit();
      }
    });
  }
  ensureCacheDirectory() {
    if (!fs.existsSync(this.cacheDir)) {
      fs.mkdirSync(this.cacheDir, { recursive: true });
      this.logger({
        category: "base_cache",
        message: `Created cache directory at ${this.cacheDir}`,
        level: 1
      });
    }
  }
  createHash(data) {
    const hash = crypto.createHash("sha256");
    return hash.update(JSON.stringify(data)).digest("hex");
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  acquireLock() {
    return __async(this, null, function* () {
      const startTime = Date.now();
      while (Date.now() - startTime < this.LOCK_TIMEOUT_MS) {
        try {
          if (fs.existsSync(this.lockFile)) {
            const lockAge = Date.now() - fs.statSync(this.lockFile).mtimeMs;
            if (lockAge > this.LOCK_TIMEOUT_MS) {
              fs.unlinkSync(this.lockFile);
              this.logger({
                category: "base_cache",
                message: "Stale lock file removed",
                level: 1
              });
            }
          }
          fs.writeFileSync(this.lockFile, process.pid.toString(), { flag: "wx" });
          this.lockAcquireFailures = 0;
          this.lockAcquired = true;
          this.logger({
            category: "base_cache",
            message: "Lock acquired",
            level: 1
          });
          return true;
        } catch (error) {
          yield this.sleep(5);
        }
      }
      this.logger({
        category: "base_cache",
        message: "Failed to acquire lock after timeout",
        level: 2
      });
      this.lockAcquireFailures++;
      if (this.lockAcquireFailures >= 3) {
        this.logger({
          category: "base_cache",
          message: "Failed to acquire lock 3 times in a row. Releasing lock manually.",
          level: 1
        });
        this.releaseLock();
      }
      return false;
    });
  }
  releaseLock() {
    try {
      if (fs.existsSync(this.lockFile)) {
        fs.unlinkSync(this.lockFile);
        this.logger({
          category: "base_cache",
          message: "Lock released",
          level: 1
        });
      }
      this.lockAcquired = false;
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: `Error releasing lock: ${error}`,
        level: 2
      });
    }
  }
  /**
   * Cleans up stale cache entries that exceed the maximum age.
   */
  cleanupStaleEntries() {
    return __async(this, null, function* () {
      if (!(yield this.acquireLock())) {
        this.logger({
          category: "llm_cache",
          message: "Failed to acquire lock for cleanup",
          level: 2
        });
        return;
      }
      try {
        const cache = this.readCache();
        const now = Date.now();
        let entriesRemoved = 0;
        for (const [hash, entry] of Object.entries(cache)) {
          if (now - entry.timestamp > this.CACHE_MAX_AGE_MS) {
            delete cache[hash];
            entriesRemoved++;
          }
        }
        if (entriesRemoved > 0) {
          this.writeCache(cache);
          this.logger({
            category: "llm_cache",
            message: `Cleaned up ${entriesRemoved} stale cache entries`,
            level: 1
          });
        }
      } catch (error) {
        this.logger({
          category: "llm_cache",
          message: `Error during cache cleanup: ${error}`,
          level: 2
        });
      } finally {
        this.releaseLock();
      }
    });
  }
  readCache() {
    if (fs.existsSync(this.cacheFile)) {
      try {
        const data = fs.readFileSync(this.cacheFile, "utf-8");
        return JSON.parse(data);
      } catch (error) {
        this.logger({
          category: "base_cache",
          message: `Error reading cache file: ${error}. Resetting cache.`,
          level: 1
        });
        this.resetCache();
        return {};
      }
    }
    return {};
  }
  writeCache(cache) {
    try {
      fs.writeFileSync(this.cacheFile, JSON.stringify(cache, null, 2));
      this.logger({
        category: "base_cache",
        message: "Cache written to file",
        level: 1
      });
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: `Error writing cache file: ${error}`,
        level: 2
      });
    } finally {
      this.releaseLock();
    }
  }
  /**
   * Retrieves data from the cache based on the provided options.
   * @param hashObj - The options used to generate the cache key.
   * @param requestId - The identifier for the current request.
   * @returns The cached data if available, otherwise null.
   */
  get(hashObj, requestId) {
    return __async(this, null, function* () {
      if (!(yield this.acquireLock())) {
        this.logger({
          category: "base_cache",
          message: "Failed to acquire lock for getting cache",
          level: 2
        });
        return null;
      }
      try {
        const hash = this.createHash(hashObj);
        const cache = this.readCache();
        if (cache[hash]) {
          this.trackRequestIdUsage(requestId, hash);
          return cache[hash].data;
        }
        return null;
      } catch (error) {
        this.logger({
          category: "base_cache",
          message: `Error getting cache: ${error}. Resetting cache.`,
          level: 1
        });
        this.resetCache();
        return null;
      } finally {
        this.releaseLock();
      }
    });
  }
  /**
   * Stores data in the cache based on the provided options and requestId.
   * @param hashObj - The options used to generate the cache key.
   * @param data - The data to be cached.
   * @param requestId - The identifier for the cache entry.
   */
  set(hashObj, data, requestId) {
    return __async(this, null, function* () {
      if (!(yield this.acquireLock())) {
        this.logger({
          category: "base_cache",
          message: "Failed to acquire lock for setting cache",
          level: 2
        });
        return;
      }
      try {
        const hash = this.createHash(hashObj);
        const cache = this.readCache();
        cache[hash] = {
          data,
          timestamp: Date.now(),
          requestId
        };
        this.writeCache(cache);
        this.trackRequestIdUsage(requestId, hash);
      } catch (error) {
        this.logger({
          category: "base_cache",
          message: `Error setting cache: ${error}. Resetting cache.`,
          level: 1
        });
        this.resetCache();
      } finally {
        this.releaseLock();
        if (Math.random() < this.CLEANUP_PROBABILITY) {
          this.cleanupStaleEntries();
        }
      }
    });
  }
  delete(hashObj) {
    return __async(this, null, function* () {
      if (!(yield this.acquireLock())) {
        this.logger({
          category: "base_cache",
          message: "Failed to acquire lock for removing cache entry",
          level: 2
        });
        return;
      }
      try {
        const hash = this.createHash(hashObj);
        const cache = this.readCache();
        if (cache[hash]) {
          delete cache[hash];
          this.writeCache(cache);
        } else {
          this.logger({
            category: "base_cache",
            message: "Cache entry not found to delete",
            level: 1
          });
        }
      } catch (error) {
        this.logger({
          category: "base_cache",
          message: `Error removing cache entry: ${error}`,
          level: 2
        });
      } finally {
        this.releaseLock();
      }
    });
  }
  /**
   * Tracks the usage of a hash with a specific requestId.
   * @param requestId - The identifier for the current request.
   * @param hash - The cache key hash.
   */
  trackRequestIdUsage(requestId, hash) {
    var _a, _b;
    (_b = (_a = this.requestIdToUsedHashes)[requestId]) != null ? _b : _a[requestId] = [];
    this.requestIdToUsedHashes[requestId].push(hash);
  }
  /**
   * Deletes all cache entries associated with a specific requestId.
   * @param requestId - The identifier for the request whose cache entries should be deleted.
   */
  deleteCacheForRequestId(requestId) {
    return __async(this, null, function* () {
      var _a;
      if (!(yield this.acquireLock())) {
        this.logger({
          category: "base_cache",
          message: "Failed to acquire lock for deleting cache",
          level: 2
        });
        return;
      }
      try {
        const cache = this.readCache();
        const hashes = (_a = this.requestIdToUsedHashes[requestId]) != null ? _a : [];
        let entriesRemoved = 0;
        for (const hash of hashes) {
          if (cache[hash]) {
            delete cache[hash];
            entriesRemoved++;
          }
        }
        if (entriesRemoved > 0) {
          this.writeCache(cache);
        } else {
          this.logger({
            category: "base_cache",
            message: `No cache entries found for requestId ${requestId}`,
            level: 1
          });
        }
        delete this.requestIdToUsedHashes[requestId];
      } catch (error) {
        this.logger({
          category: "base_cache",
          message: `Error deleting cache for requestId ${requestId}: ${error}`,
          level: 2
        });
      } finally {
        this.releaseLock();
      }
    });
  }
  /**
   * Resets the entire cache by clearing the cache file.
   */
  resetCache() {
    try {
      fs.writeFileSync(this.cacheFile, "{}");
      this.requestIdToUsedHashes = {};
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: `Error resetting cache: ${error}`,
        level: 2
      });
    } finally {
      this.releaseLock();
    }
  }
};

// lib/cache/LLMCache.ts
var LLMCache = class _LLMCache extends BaseCache {
  constructor(logger, cacheDir, cacheFile) {
    super(logger, cacheDir, cacheFile || "llm_calls.json");
  }
  /**
   * Overrides the get method to track used hashes by requestId.
   * @param options - The options used to generate the cache key.
   * @param requestId - The identifier for the current request.
   * @returns The cached data if available, otherwise null.
   */
  get(options, requestId) {
    return __async(this, null, function* () {
      const data = yield __superGet(_LLMCache.prototype, this, "get").call(this, options, requestId);
      return data;
    });
  }
  /**
   * Overrides the set method to include cache cleanup logic.
   * @param options - The options used to generate the cache key.
   * @param data - The data to be cached.
   * @param requestId - The identifier for the current request.
   */
  set(options, data, requestId) {
    return __async(this, null, function* () {
      yield __superGet(_LLMCache.prototype, this, "set").call(this, options, data, requestId);
      this.logger({
        category: "llm_cache",
        message: "Cache miss - saved new response",
        level: 1
      });
    });
  }
};

// lib/llm/LLMProvider.ts
var LLMProvider = class {
  constructor(logger, enableCaching) {
    this.modelToProviderMap = {
      "gpt-4o": "openai",
      "gpt-4o-mini": "openai",
      "gpt-4o-2024-08-06": "openai",
      "claude-3-5-sonnet-latest": "anthropic",
      "claude-3-5-sonnet-20240620": "anthropic",
      "claude-3-5-sonnet-20241022": "anthropic"
    };
    this.logger = logger;
    this.enableCaching = enableCaching;
    this.cache = new LLMCache(logger);
  }
  cleanRequestCache(requestId) {
    this.logger({
      category: "llm_cache",
      message: `Cleaning up cache for requestId: ${requestId}`
    });
    this.cache.deleteCacheForRequestId(requestId);
  }
  getClient(modelName, requestId) {
    const provider = this.modelToProviderMap[modelName];
    if (!provider) {
      throw new Error(`Unsupported model: ${modelName}`);
    }
    switch (provider) {
      case "openai":
        return new OpenAIClient(
          this.logger,
          this.enableCaching,
          this.cache,
          requestId
        );
      case "anthropic":
        return new AnthropicClient(
          this.logger,
          this.enableCaching,
          this.cache,
          requestId
        );
      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }
};

// lib/index.ts
var import_path2 = __toESM(require("path"));

// lib/vision.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_sharp = __toESM(require("sharp"));
var import_child_process = require("child_process");
var ScreenshotService = class _ScreenshotService {
  constructor(page, selectorMap, verbose, isDebugEnabled = false) {
    this.annotationBoxes = [];
    this.numberPositions = [];
    this.page = page;
    this.selectorMap = selectorMap;
    this.isDebugEnabled = isDebugEnabled;
    this.verbose = verbose;
  }
  log({
    category,
    message,
    level = 1
  }) {
    if (this.verbose >= level) {
      const categoryString = category ? `:${category}` : "";
      console.log(`[stagehand${categoryString}] ${message}`);
    }
  }
  getScreenshot(fullpage = true, quality) {
    return __async(this, null, function* () {
      if (quality && (quality < 0 || quality > 100)) {
        throw new Error("quality must be between 0 and 100");
      }
      return yield this.page.screenshot({
        fullPage: fullpage,
        quality,
        type: "jpeg"
      });
    });
  }
  getScreenshotPixelCount(screenshot) {
    return __async(this, null, function* () {
      const image = (0, import_sharp.default)(screenshot);
      const metadata = yield image.metadata();
      if (!metadata.width || !metadata.height) {
        this.log({
          category: "Error",
          message: "Unable to determine image dimensions.",
          level: 0
        });
        throw new Error("Unable to determine image dimensions.");
      }
      const pixelCount = metadata.width * metadata.height;
      this.log({
        category: "Info",
        message: `Screenshot pixel count: ${pixelCount}`,
        level: 1
      });
      return pixelCount;
    });
  }
  getAnnotatedScreenshot(fullpage) {
    return __async(this, null, function* () {
      this.annotationBoxes = [];
      this.numberPositions = [];
      const screenshot = yield this.getScreenshot(fullpage);
      const image = (0, import_sharp.default)(screenshot);
      const { width, height } = yield image.metadata();
      const svgAnnotations = yield Promise.all(
        Object.entries(this.selectorMap).map(
          (_0) => __async(this, [_0], function* ([id, selectors]) {
            return this.createElementAnnotation(id, selectors);
          })
        )
      );
      const scrollPosition = yield this.page.evaluate(() => {
        return {
          scrollX: window.scrollX,
          scrollY: window.scrollY
        };
      });
      const svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" style="position:absolute;left:${-scrollPosition.scrollX}px;top:${-scrollPosition.scrollY}px;">
        ${svgAnnotations.join("")}
      </svg>
    `;
      const annotatedScreenshot = yield image.composite([{ input: Buffer.from(svg), top: 0, left: 0 }]).toBuffer();
      if (this.isDebugEnabled) {
        yield _ScreenshotService.saveAndOpenScreenshot(annotatedScreenshot);
      }
      return annotatedScreenshot;
    });
  }
  createElementAnnotation(id, selectors) {
    return __async(this, null, function* () {
      try {
        let element = null;
        const selectorPromises = selectors.map(
          (selector) => __async(this, null, function* () {
            try {
              element = yield this.page.locator(`xpath=${selector}`).first();
              const box2 = yield element.boundingBox({ timeout: 5e3 });
              return box2;
            } catch (e) {
              return null;
            }
          })
        );
        const boxes = yield Promise.all(selectorPromises);
        const box = boxes.find((b) => b !== null);
        if (!box) {
          throw new Error(`Unable to create annotation for element ${id}`);
        }
        const scrollPosition = yield this.page.evaluate(() => ({
          scrollX: window.scrollX,
          scrollY: window.scrollY
        }));
        const adjustedBox = {
          x: box.x + scrollPosition.scrollX,
          y: box.y + scrollPosition.scrollY,
          width: box.width,
          height: box.height,
          id
        };
        this.annotationBoxes.push(adjustedBox);
        const numberPosition = this.findNonOverlappingNumberPosition(adjustedBox);
        const circleRadius = 12;
        return `
        <rect x="${adjustedBox.x}" y="${adjustedBox.y}" width="${adjustedBox.width}" height="${adjustedBox.height}" 
              fill="none" stroke="red" stroke-width="2" />
        <circle cx="${numberPosition.x}" cy="${numberPosition.y}" r="${circleRadius}" fill="white" stroke="red" stroke-width="2" />
        <text x="${numberPosition.x}" y="${numberPosition.y}" fill="red" font-size="16" font-weight="bold" 
              text-anchor="middle" dominant-baseline="central">
          ${id}
        </text>
      `;
      } catch (error) {
        this.log({
          category: "Vision",
          message: `Warning: Failed to create annotation for element ${id}: ${error}, trace: ${error.stack}`,
          level: 0
        });
        return "";
      }
    });
  }
  findNonOverlappingNumberPosition(box) {
    const circleRadius = 12;
    let position = {
      x: box.x - circleRadius,
      y: box.y - circleRadius
    };
    let attempts = 0;
    const maxAttempts = 10;
    const offset = 5;
    while (this.isNumberOverlapping(position) && attempts < maxAttempts) {
      position.y += offset;
      attempts++;
    }
    this.numberPositions.push(position);
    return position;
  }
  isNumberOverlapping(position) {
    const circleRadius = 12;
    return this.numberPositions.some(
      (existingPosition) => Math.sqrt(
        Math.pow(position.x - existingPosition.x, 2) + Math.pow(position.y - existingPosition.y, 2)
      ) < circleRadius * 2
    );
  }
  static saveAndOpenScreenshot(screenshot) {
    return __async(this, null, function* () {
      const screenshotDir = import_path.default.join(process.cwd(), "screenshots");
      if (!import_fs.default.existsSync(screenshotDir)) {
        import_fs.default.mkdirSync(screenshotDir);
      }
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const filename = import_path.default.join(screenshotDir, `screenshot-${timestamp}.png`);
      import_fs.default.writeFileSync(filename, screenshot);
      console.log(`Screenshot saved to: ${filename}`);
      if (process.platform === "win32") {
        (0, import_child_process.exec)(`start ${filename}`);
      } else if (process.platform === "darwin") {
        (0, import_child_process.exec)(`open ${filename}`);
      } else {
        (0, import_child_process.exec)(`xdg-open ${filename}`);
      }
    });
  }
};

// lib/types.ts
var PlaywrightCommandException = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PlaywrightCommandException";
  }
};
var PlaywrightCommandMethodNotSupportedException = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PlaywrightCommandMethodNotSupportedException";
  }
};

// lib/cache/ActionCache.ts
var ActionCache = class _ActionCache extends BaseCache {
  constructor(logger, cacheDir, cacheFile) {
    super(logger, cacheDir, cacheFile || "action_cache.json");
  }
  addActionStep(_0) {
    return __async(this, arguments, function* ({
      url,
      action,
      previousSelectors,
      playwrightCommand,
      componentString,
      xpaths,
      newStepString,
      completed,
      requestId
    }) {
      this.logger({
        category: "action_cache",
        message: `Adding action step to cache: ${action}, requestId: ${requestId}, url: ${url}, previousSelectors: ${previousSelectors}`,
        level: 1
      });
      yield this.set(
        { url, action, previousSelectors },
        {
          playwrightCommand,
          componentString,
          xpaths,
          newStepString,
          completed,
          previousSelectors,
          action
        },
        requestId
      );
    });
  }
  /**
   * Retrieves all actions for a specific trajectory.
   * @param trajectoryId - Unique identifier for the trajectory.
   * @param requestId - The identifier for the current request.
   * @returns An array of TrajectoryEntry objects or null if not found.
   */
  getActionStep(_0) {
    return __async(this, arguments, function* ({
      url,
      action,
      previousSelectors,
      requestId
    }) {
      const data = yield __superGet(_ActionCache.prototype, this, "get").call(this, { url, action, previousSelectors }, requestId);
      if (!data) {
        return null;
      }
      return data;
    });
  }
  removeActionStep(cacheHashObj) {
    return __async(this, null, function* () {
      yield __superGet(_ActionCache.prototype, this, "delete").call(this, cacheHashObj);
    });
  }
  /**
   * Clears all actions for a specific trajectory.
   * @param trajectoryId - Unique identifier for the trajectory.
   * @param requestId - The identifier for the current request.
   */
  clearAction(requestId) {
    return __async(this, null, function* () {
      yield __superGet(_ActionCache.prototype, this, "deleteCacheForRequestId").call(this, requestId);
      this.logger({
        category: "action_cache",
        message: `Cleared action for ID: ${requestId}`,
        level: 1
      });
    });
  }
  /**
   * Resets the entire action cache.
   */
  resetCache() {
    return __async(this, null, function* () {
      yield __superGet(_ActionCache.prototype, this, "resetCache").call(this);
      this.logger({
        category: "action_cache",
        message: "Action cache has been reset.",
        level: 1
      });
    });
  }
};

// lib/utils.ts
var import_crypto = __toESM(require("crypto"));
function generateId(operation) {
  return import_crypto.default.createHash("sha256").update(operation).digest("hex");
}

// lib/handlers/actHandler.ts
var StagehandActHandler = class {
  constructor({
    stagehand,
    verbose,
    llmProvider,
    enableCaching,
    logger,
    waitForSettledDom,
    defaultModelName,
    startDomDebug,
    cleanupDomDebug
  }) {
    this.stagehand = stagehand;
    this.verbose = verbose;
    this.llmProvider = llmProvider;
    this.enableCaching = enableCaching;
    this.logger = logger;
    this.waitForSettledDom = waitForSettledDom;
    this.actionCache = new ActionCache(this.logger);
    this.defaultModelName = defaultModelName;
    this.startDomDebug = startDomDebug;
    this.cleanupDomDebug = cleanupDomDebug;
    this.actions = {};
  }
  _recordAction(action, result) {
    return __async(this, null, function* () {
      const id = generateId(action);
      this.actions[id] = { result, action };
      return id;
    });
  }
  _verifyActionCompletion(_0) {
    return __async(this, arguments, function* ({
      completed,
      verifierUseVision,
      requestId,
      action,
      steps,
      model,
      domSettleTimeoutMs
    }) {
      yield this.waitForSettledDom(domSettleTimeoutMs);
      const { selectorMap } = yield this.stagehand.page.evaluate(() => {
        return window.processAllOfDom();
      });
      let actionCompleted = false;
      if (completed) {
        this.stagehand.log({
          category: "action",
          message: `Action marked as completed, Verifying if this is true...`,
          level: 1
        });
        let domElements = void 0;
        let fullpageScreenshot = void 0;
        if (verifierUseVision) {
          try {
            const screenshotService = new ScreenshotService(
              this.stagehand.page,
              selectorMap,
              this.verbose
            );
            fullpageScreenshot = yield screenshotService.getScreenshot(true, 15);
          } catch (e) {
            this.stagehand.log({
              category: "action",
              message: `Error getting full page screenshot: ${e.message}
. Trying again...`,
              level: 1
            });
            const screenshotService = new ScreenshotService(
              this.stagehand.page,
              selectorMap,
              this.verbose
            );
            fullpageScreenshot = yield screenshotService.getScreenshot(true, 15);
          }
        } else {
          ({ outputString: domElements } = yield this.stagehand.page.evaluate(
            () => {
              return window.processAllOfDom();
            }
          ));
        }
        actionCompleted = yield verifyActCompletion({
          goal: action,
          steps,
          llmProvider: this.llmProvider,
          modelName: model,
          screenshot: fullpageScreenshot,
          domElements,
          logger: this.logger,
          requestId
        });
        this.stagehand.log({
          category: "action",
          message: `Action completion verification result: ${actionCompleted}`,
          level: 1
        });
      }
      return actionCompleted;
    });
  }
  _performPlaywrightMethod(method, args, xpath, domSettleTimeoutMs) {
    return __async(this, null, function* () {
      const locator = this.stagehand.page.locator(`xpath=${xpath}`).first();
      const initialUrl = this.stagehand.page.url();
      if (method === "scrollIntoView") {
        this.stagehand.log({
          category: "action",
          message: `Scrolling element into view`,
          level: 2
        });
        try {
          yield locator.evaluate((element) => {
            element.scrollIntoView({ behavior: "smooth", block: "center" });
          }).catch((e) => {
            this.stagehand.log({
              category: "action",
              message: `Error scrolling element into view: ${e.message}
Trace: ${e.stack}`,
              level: 1
            });
          });
        } catch (e) {
          this.stagehand.log({
            category: "action",
            message: `Error scrolling element into view: ${e.message}
Trace: ${e.stack}`,
            level: 1
          });
          throw new PlaywrightCommandException(e.message);
        }
      } else if (method === "fill" || method === "type") {
        try {
          yield locator.fill("");
          yield locator.click();
          const text = args[0];
          for (const char of text) {
            yield this.stagehand.page.keyboard.type(char, {
              delay: Math.random() * 50 + 25
            });
          }
        } catch (e) {
          this.logger({
            category: "action",
            message: `Error filling element: ${e.message}
Trace: ${e.stack}`,
            level: 1
          });
          throw new PlaywrightCommandException(e.message);
        }
      } else if (method === "press") {
        try {
          const key = args[0];
          yield this.stagehand.page.keyboard.press(key);
        } catch (e) {
          this.logger({
            category: "action",
            message: `Error pressing key: ${e.message}
Trace: ${e.stack}`,
            level: 1
          });
          throw new PlaywrightCommandException(e.message);
        }
      } else if (typeof locator[method] === "function") {
        this.logger({
          category: "action",
          message: `Page URL before action: ${this.stagehand.page.url()}`,
          level: 2
        });
        try {
          yield locator[method](...args);
        } catch (e) {
          this.logger({
            category: "action",
            message: `Error performing method ${method} with args ${JSON.stringify(
              args
            )}: ${e.message}
Trace: ${e.stack}`,
            level: 1
          });
          throw new PlaywrightCommandException(e.message);
        }
        if (method === "click") {
          this.logger({
            category: "action",
            message: `Clicking element, checking for page navigation`,
            level: 1
          });
          const newOpenedTab = yield Promise.race([
            new Promise((resolve) => {
              this.stagehand.context.once("page", (page) => resolve(page));
              setTimeout(() => resolve(null), 1500);
            })
          ]);
          this.logger({
            category: "action",
            message: `Clicked element, ${newOpenedTab ? "opened a new tab" : "no new tabs opened"}`,
            level: 1
          });
          if (newOpenedTab) {
            this.logger({
              category: "action",
              message: `New page detected (new tab) with URL: ${newOpenedTab.url()}`,
              level: 1
            });
            yield newOpenedTab.close();
            yield this.stagehand.page.goto(newOpenedTab.url());
            yield this.stagehand.page.waitForLoadState("domcontentloaded");
            yield this.waitForSettledDom(domSettleTimeoutMs);
          }
          yield Promise.race([
            this.stagehand.page.waitForLoadState("networkidle"),
            new Promise((resolve) => setTimeout(resolve, 5e3))
          ]).catch((e) => {
            this.logger({
              category: "action",
              message: `Network idle timeout hit`,
              level: 1
            });
          });
          this.logger({
            category: "action",
            message: `Finished waiting for (possible) page navigation`,
            level: 1
          });
          if (this.stagehand.page.url() !== initialUrl) {
            this.logger({
              category: "action",
              message: `New page detected with URL: ${this.stagehand.page.url()}`,
              level: 1
            });
          }
        }
      } else {
        this.logger({
          category: "action",
          message: `Chosen method ${method} is invalid`,
          level: 1
        });
        throw new PlaywrightCommandMethodNotSupportedException(
          `Method ${method} not supported`
        );
      }
      yield this.waitForSettledDom(domSettleTimeoutMs);
    });
  }
  _getComponentString(locator) {
    return __async(this, null, function* () {
      return yield locator.evaluate((el) => {
        const clone = el.cloneNode(true);
        const attributesToKeep = [
          "type",
          "name",
          "placeholder",
          "aria-label",
          "role",
          "href",
          "title",
          "alt"
        ];
        Array.from(clone.attributes).forEach((attr) => {
          if (!attributesToKeep.includes(attr.name)) {
            clone.removeAttribute(attr.name);
          }
        });
        const outerHtml = clone.outerHTML;
        return outerHtml.trim().replace(/\s+/g, " ");
      });
    });
  }
  getElement(xpath, timeout = 5e3) {
    return __async(this, null, function* () {
      try {
        const element = this.stagehand.page.locator(`xpath=${xpath}`).first();
        yield element.waitFor({ state: "attached", timeout });
        return element;
      } catch (e) {
        this.logger({
          category: "action",
          message: `Element with XPath ${xpath} not found within ${timeout}ms.`,
          level: 1
        });
        return null;
      }
    });
  }
  _checkIfCachedStepIsValid_oneXpath(cachedStep) {
    return __async(this, null, function* () {
      this.logger({
        category: "action",
        message: `Checking if cached step is valid: ${cachedStep.xpath}, ${cachedStep.savedComponentString}`,
        level: 1
      });
      try {
        const locator = yield this.getElement(cachedStep.xpath);
        if (!locator) {
          this.logger({
            category: "action",
            message: `Locator not found for xpath: ${cachedStep.xpath}`,
            level: 1
          });
          return false;
        }
        this.logger({
          category: "action",
          message: `locator element: ${yield this._getComponentString(locator)}`,
          level: 1
        });
        let currentComponent = yield this._getComponentString(locator);
        this.logger({
          category: "action",
          message: `Current text: ${currentComponent}`,
          level: 1
        });
        if (!currentComponent || !cachedStep.savedComponentString) {
          this.logger({
            category: "action",
            message: `Current text or cached text is undefined`,
            level: 1
          });
          return false;
        }
        const normalizedCurrentText = currentComponent.trim().replace(/\s+/g, " ");
        const normalizedCachedText = cachedStep.savedComponentString.trim().replace(/\s+/g, " ");
        if (normalizedCurrentText !== normalizedCachedText) {
          this.logger({
            category: "action",
            message: `Current text and cached text do not match: ${normalizedCurrentText} !== ${normalizedCachedText}`,
            level: 1
          });
          return false;
        }
        return true;
      } catch (e) {
        this.logger({
          category: "action",
          message: `Error checking if cached step is valid: ${e.message}
Trace: ${e.stack}`,
          level: 1
        });
        return false;
      }
    });
  }
  _getValidCachedStepXpath(cachedStep) {
    return __async(this, null, function* () {
      const reversedXpaths = [...cachedStep.xpaths].reverse();
      for (const xpath of reversedXpaths) {
        const isValid = yield this._checkIfCachedStepIsValid_oneXpath({
          xpath,
          savedComponentString: cachedStep.savedComponentString
        });
        if (isValid) {
          return xpath;
        }
      }
      return null;
    });
  }
  _runCachedActionIfAvailable(_0) {
    return __async(this, arguments, function* ({
      action,
      previousSelectors,
      requestId,
      steps,
      chunksSeen,
      modelName,
      useVision,
      verifierUseVision,
      retries,
      variables,
      model,
      domSettleTimeoutMs
    }) {
      const cacheObj = {
        url: this.stagehand.page.url(),
        action,
        previousSelectors,
        requestId
      };
      this.logger({
        category: "action",
        message: `Checking action cache for: ${JSON.stringify(cacheObj)}`,
        level: 1
      });
      const cachedStep = yield this.actionCache.getActionStep(cacheObj);
      if (!cachedStep) {
        this.logger({
          category: "action",
          message: `Action cache miss: ${JSON.stringify(cacheObj)}`,
          level: 1
        });
        return null;
      }
      this.logger({
        category: "action",
        message: `Action cache semi-hit: ${cachedStep.playwrightCommand.method} with args: ${JSON.stringify(
          cachedStep.playwrightCommand.args
        )}`,
        level: 1
      });
      try {
        const validXpath = yield this._getValidCachedStepXpath({
          xpaths: cachedStep.xpaths,
          savedComponentString: cachedStep.componentString
        });
        this.logger({
          category: "action",
          message: `Cached action step is valid: ${validXpath !== null}`,
          level: 1
        });
        if (!validXpath) {
          this.logger({
            category: "action",
            message: `Cached action step is invalid, removing...`,
            level: 1
          });
          yield this.actionCache.removeActionStep(cacheObj);
          return null;
        }
        this.logger({
          category: "action",
          message: `Action Cache Hit: ${cachedStep.playwrightCommand.method} with args: ${JSON.stringify(
            cachedStep.playwrightCommand.args
          )}`,
          level: 1
        });
        cachedStep.playwrightCommand.args = cachedStep.playwrightCommand.args.map(
          (arg) => {
            return fillInVariables(arg, variables);
          }
        );
        yield this._performPlaywrightMethod(
          cachedStep.playwrightCommand.method,
          cachedStep.playwrightCommand.args,
          validXpath,
          domSettleTimeoutMs
        );
        steps = steps + cachedStep.newStepString;
        const { outputString, selectorMap } = yield this.stagehand.page.evaluate(
          ({ chunksSeen: chunksSeen2 }) => {
            return window.processDom(chunksSeen2);
          },
          { chunksSeen }
        );
        if (cachedStep.completed) {
          let actionCompleted = yield this._verifyActionCompletion({
            completed: true,
            verifierUseVision,
            model,
            steps,
            requestId,
            action,
            domSettleTimeoutMs
          });
          this.logger({
            category: "action",
            message: `Action completion verification result from cache: ${actionCompleted}`,
            level: 1
          });
          if (actionCompleted) {
            return {
              success: true,
              message: "Action completed successfully using cached step",
              action
            };
          }
        }
        return this.act({
          action,
          steps,
          chunksSeen,
          modelName,
          useVision,
          verifierUseVision,
          retries,
          requestId,
          variables,
          previousSelectors: [...previousSelectors, cachedStep.xpaths[0]],
          skipActionCacheForThisStep: false,
          domSettleTimeoutMs
        });
      } catch (exception) {
        this.logger({
          category: "action",
          message: `Error performing cached action step: ${exception.message}
Trace: ${exception.stack}`,
          level: 1
        });
        yield this.actionCache.removeActionStep(cacheObj);
        return null;
      }
    });
  }
  act(_0) {
    return __async(this, arguments, function* ({
      action,
      steps = "",
      chunksSeen,
      modelName,
      useVision,
      verifierUseVision,
      retries = 0,
      requestId,
      variables,
      previousSelectors,
      skipActionCacheForThisStep = false,
      domSettleTimeoutMs
    }) {
      var _a;
      try {
        yield this.waitForSettledDom(domSettleTimeoutMs);
        yield this.startDomDebug();
        const model = modelName != null ? modelName : this.defaultModelName;
        if (this.enableCaching && !skipActionCacheForThisStep) {
          const response2 = yield this._runCachedActionIfAvailable({
            action,
            previousSelectors,
            requestId,
            steps,
            chunksSeen,
            modelName: model,
            useVision,
            verifierUseVision,
            retries,
            variables,
            model,
            domSettleTimeoutMs
          });
          if (response2 !== null) {
            return response2;
          } else {
            return this.act({
              action,
              steps,
              chunksSeen,
              modelName,
              useVision,
              verifierUseVision,
              retries,
              requestId,
              variables,
              previousSelectors,
              skipActionCacheForThisStep: true,
              domSettleTimeoutMs
            });
          }
        }
        if (!modelsWithVision.includes(model) && (useVision !== false || verifierUseVision)) {
          this.logger({
            category: "action",
            message: `${model} does not support vision, but useVision was set to ${useVision}. Defaulting to false.`,
            level: 1
          });
          useVision = false;
          verifierUseVision = false;
        }
        this.logger({
          category: "action",
          message: `Running / Continuing action: ${action} on page: ${this.stagehand.page.url()}`,
          level: 2
        });
        this.logger({
          category: "action",
          message: `Processing DOM...`,
          level: 2
        });
        const { outputString, selectorMap, chunk, chunks } = yield this.stagehand.page.evaluate(
          ({ chunksSeen: chunksSeen2 }) => {
            return window.processDom(chunksSeen2);
          },
          { chunksSeen }
        );
        this.logger({
          category: "action",
          message: `Looking at chunk ${chunk}. Chunks left: ${chunks.length - chunksSeen.length}`,
          level: 1
        });
        let annotatedScreenshot;
        if (useVision === true) {
          if (!modelsWithVision.includes(model)) {
            this.logger({
              category: "action",
              message: `${model} does not support vision. Skipping vision processing.`,
              level: 1
            });
          } else {
            const screenshotService = new ScreenshotService(
              this.stagehand.page,
              selectorMap,
              this.verbose
            );
            annotatedScreenshot = yield screenshotService.getAnnotatedScreenshot(false);
          }
        }
        const response = yield act({
          action,
          domElements: outputString,
          steps,
          llmProvider: this.llmProvider,
          modelName: model,
          screenshot: annotatedScreenshot,
          logger: this.logger,
          requestId,
          variables
        });
        this.logger({
          category: "action",
          message: `Received response from LLM: ${JSON.stringify(response)}`,
          level: 1
        });
        yield this.cleanupDomDebug();
        if (!response) {
          if (chunksSeen.length + 1 < chunks.length) {
            chunksSeen.push(chunk);
            this.logger({
              category: "action",
              message: `No action found in current chunk. Chunks seen: ${chunksSeen.length}.`,
              level: 1
            });
            return this.act({
              action,
              steps: steps + (!steps.endsWith("\n") ? "\n" : "") + "## Step: Scrolled to another section\n",
              chunksSeen,
              modelName,
              useVision,
              verifierUseVision,
              requestId,
              variables,
              previousSelectors,
              skipActionCacheForThisStep,
              domSettleTimeoutMs
            });
          } else if (useVision === "fallback") {
            this.logger({
              category: "action",
              message: `Switching to vision-based processing`,
              level: 1
            });
            yield this.stagehand.page.evaluate(() => window.scrollToHeight(0));
            return yield this.act({
              action,
              steps,
              chunksSeen,
              modelName,
              useVision: true,
              verifierUseVision,
              requestId,
              variables,
              previousSelectors,
              skipActionCacheForThisStep,
              domSettleTimeoutMs
            });
          } else {
            if (this.enableCaching) {
              this.llmProvider.cleanRequestCache(requestId);
              this.actionCache.deleteCacheForRequestId(requestId);
            }
            return {
              success: false,
              message: `Action was not able to be completed.`,
              action
            };
          }
        }
        const elementId = response["element"];
        const xpaths = selectorMap[elementId];
        const method = response["method"];
        const args = response["args"];
        const elementLines = outputString.split("\n");
        const elementText = ((_a = elementLines.find((line) => line.startsWith(`${elementId}:`))) == null ? void 0 : _a.split(":")[1]) || "Element not found";
        this.logger({
          category: "action",
          message: `Executing method: ${method} on element: ${elementId} (xpaths: ${xpaths.join(
            ", "
          )}) with args: ${JSON.stringify(args)}`,
          level: 1
        });
        try {
          const initialUrl = this.stagehand.page.url();
          const locator = this.stagehand.page.locator(`xpath=${xpaths[0]}`).first();
          const originalUrl = this.stagehand.page.url();
          const componentString = yield this._getComponentString(locator);
          const responseArgs = [...args];
          if (variables) {
            responseArgs.forEach((arg, index) => {
              if (typeof arg === "string") {
                args[index] = fillInVariables(arg, variables);
              }
            });
          }
          yield this._performPlaywrightMethod(
            method,
            args,
            xpaths[0],
            domSettleTimeoutMs
          );
          const newStepString = (!steps.endsWith("\n") ? "\n" : "") + `## Step: ${response.step}
  Element: ${elementText}
  Action: ${response.method}
  Reasoning: ${response.why}
`;
          steps += newStepString;
          if (this.enableCaching) {
            this.actionCache.addActionStep({
              action,
              url: originalUrl,
              previousSelectors,
              playwrightCommand: {
                method,
                args: responseArgs
              },
              componentString,
              requestId,
              xpaths,
              newStepString,
              completed: response.completed
            }).catch((e) => {
              this.logger({
                category: "action",
                message: `Error adding action step to cache: ${e.message}
Trace: ${e.stack}`,
                level: 1
              });
            });
          }
          if (this.stagehand.page.url() !== initialUrl) {
            steps += `  Result (Important): Page URL changed from ${initialUrl} to ${this.stagehand.page.url()}

`;
          }
          const actionCompleted = yield this._verifyActionCompletion({
            completed: response.completed,
            verifierUseVision,
            requestId,
            action,
            steps,
            model,
            domSettleTimeoutMs
          });
          if (!actionCompleted) {
            this.logger({
              category: "action",
              message: `Continuing to next action step`,
              level: 1
            });
            return this.act({
              action,
              steps,
              modelName,
              chunksSeen,
              useVision,
              verifierUseVision,
              requestId,
              variables,
              previousSelectors: [...previousSelectors, xpaths[0]],
              skipActionCacheForThisStep: false,
              domSettleTimeoutMs
            });
          } else {
            this.logger({
              category: "action",
              message: `Action completed successfully`,
              level: 1
            });
            yield this._recordAction(action, response.step);
            return {
              success: true,
              message: `Action completed successfully: ${steps}${response.step}`,
              action
            };
          }
        } catch (error) {
          this.logger({
            category: "action",
            message: `Error performing action - D (Retries: ${retries}): ${error.message}
Trace: ${error.stack}`,
            level: 1
          });
          if (retries < 2) {
            return this.act({
              action,
              steps,
              modelName,
              useVision,
              verifierUseVision,
              retries: retries + 1,
              chunksSeen,
              requestId,
              variables,
              previousSelectors,
              skipActionCacheForThisStep,
              domSettleTimeoutMs
            });
          }
          yield this._recordAction(action, "");
          if (this.enableCaching) {
            this.llmProvider.cleanRequestCache(requestId);
            this.actionCache.deleteCacheForRequestId(requestId);
          }
          return {
            success: false,
            message: `Error performing action - A: ${error.message}`,
            action
          };
        }
      } catch (error) {
        this.logger({
          category: "action",
          message: `Error performing action - B: ${error.message}
Trace: ${error.stack}`,
          level: 1
        });
        if (this.enableCaching) {
          this.llmProvider.cleanRequestCache(requestId);
          this.actionCache.deleteCacheForRequestId(requestId);
        }
        return {
          success: false,
          message: `Error performing action - C: ${error.message}`,
          action
        };
      }
    });
  }
};

// lib/index.ts
require("dotenv").config({ path: ".env" });
function getBrowser(apiKey, projectId, env = "LOCAL", headless = false, logger, browserbaseSessionCreateParams, browserbaseResumeSessionID) {
  return __async(this, null, function* () {
    if (env === "BROWSERBASE") {
      if (!apiKey) {
        logger({
          category: "Init",
          message: "BROWSERBASE_API_KEY is required to use BROWSERBASE env. Defaulting to LOCAL.",
          level: 0
        });
        env = "LOCAL";
      }
      if (!projectId) {
        logger({
          category: "Init",
          message: "BROWSERBASE_PROJECT_ID is required for some Browserbase features that may not work without it.",
          level: 1
        });
      }
    }
    if (env === "BROWSERBASE") {
      if (!apiKey) {
        throw new Error("BROWSERBASE_API_KEY is required.");
      }
      let debugUrl = void 0;
      let sessionUrl = void 0;
      let sessionId;
      let connectUrl;
      const browserbase = new import_sdk2.Browserbase({
        apiKey
      });
      if (browserbaseResumeSessionID) {
        try {
          const sessionStatus = yield browserbase.sessions.retrieve(
            browserbaseResumeSessionID
          );
          if (sessionStatus.status !== "RUNNING") {
            throw new Error(
              `Session ${browserbaseResumeSessionID} is not running (status: ${sessionStatus.status})`
            );
          }
          sessionId = browserbaseResumeSessionID;
          connectUrl = `wss://connect.browserbase.com?apiKey=${apiKey}&sessionId=${sessionId}`;
          logger({
            category: "Init",
            message: "Resuming existing Browserbase session...",
            level: 0
          });
        } catch (error) {
          logger({
            category: "Init",
            message: `Failed to resume session ${browserbaseResumeSessionID}: ${error.message}`,
            level: 0
          });
          throw error;
        }
      } else {
        logger({
          category: "Init",
          message: "Creating new Browserbase session...",
          level: 0
        });
        if (!projectId) {
          throw new Error(
            "BROWSERBASE_PROJECT_ID is required for new Browserbase sessions."
          );
        }
        const session = yield browserbase.sessions.create(__spreadValues({
          projectId
        }, browserbaseSessionCreateParams));
        sessionId = session.id;
        connectUrl = session.connectUrl;
      }
      const browser = yield import_test.chromium.connectOverCDP(connectUrl);
      const { debuggerUrl } = yield browserbase.sessions.debug(sessionId);
      debugUrl = debuggerUrl;
      sessionUrl = `https://www.browserbase.com/sessions/${sessionId}`;
      logger({
        category: "Init",
        message: `Browserbase session ${browserbaseResumeSessionID ? "resumed" : "started"}.

Session Url: ${sessionUrl}

Live debug accessible here: ${debugUrl}.`,
        level: 0
      });
      const context = browser.contexts()[0];
      return { browser, context, debugUrl, sessionUrl };
    } else {
      logger({
        category: "Init",
        message: `Launching local browser in ${headless ? "headless" : "headed"} mode`,
        level: 0
      });
      const tmpDir = import_fs2.default.mkdtempSync(`/tmp/pwtest`);
      import_fs2.default.mkdirSync(`${tmpDir}/userdir/Default`, { recursive: true });
      const defaultPreferences = {
        plugins: {
          always_open_pdf_externally: true
        }
      };
      import_fs2.default.writeFileSync(
        `${tmpDir}/userdir/Default/Preferences`,
        JSON.stringify(defaultPreferences)
      );
      const downloadsPath = `${process.cwd()}/downloads`;
      import_fs2.default.mkdirSync(downloadsPath, { recursive: true });
      const context = yield import_test.chromium.launchPersistentContext(
        `${tmpDir}/userdir`,
        {
          acceptDownloads: true,
          headless,
          viewport: {
            width: 1250,
            height: 800
          },
          locale: "en-US",
          timezoneId: "America/New_York",
          deviceScaleFactor: 1,
          args: [
            "--enable-webgl",
            "--use-gl=swiftshader",
            "--enable-accelerated-2d-canvas",
            "--disable-blink-features=AutomationControlled",
            "--disable-web-security"
          ],
          bypassCSP: true
        }
      );
      logger({
        category: "Init",
        message: "Local browser started successfully."
      });
      yield applyStealthScripts(context);
      return { context };
    }
  });
}
function applyStealthScripts(context) {
  return __async(this, null, function* () {
    yield context.addInitScript(() => {
      Object.defineProperty(navigator, "webdriver", {
        get: () => void 0
      });
      Object.defineProperty(navigator, "languages", {
        get: () => ["en-US", "en"]
      });
      Object.defineProperty(navigator, "plugins", {
        get: () => [1, 2, 3, 4, 5]
      });
      delete window.__playwright;
      delete window.__pw_manual;
      delete window.__PW_inspect;
      Object.defineProperty(navigator, "headless", {
        get: () => false
      });
      const originalQuery = window.navigator.permissions.query;
      window.navigator.permissions.query = (parameters) => parameters.name === "notifications" ? Promise.resolve({
        state: Notification.permission
      }) : originalQuery(parameters);
    });
  });
}
var Stagehand = class {
  constructor({
    env,
    apiKey,
    projectId,
    verbose,
    debugDom,
    llmProvider,
    headless,
    logger,
    browserBaseSessionCreateParams,
    domSettleTimeoutMs,
    enableCaching,
    browserbaseResumeSessionID
  } = {
    env: "BROWSERBASE"
  }) {
    // Logging
    this.pending_logs_to_send_to_browserbase = [];
    this.is_processing_browserbase_logs = false;
    this.externalLogger = logger;
    this.logger = this.log.bind(this);
    this.enableCaching = enableCaching != null ? enableCaching : false;
    this.llmProvider = llmProvider || new LLMProvider(this.logger, this.enableCaching);
    this.env = env;
    this.observations = {};
    this.apiKey = apiKey != null ? apiKey : process.env.BROWSERBASE_API_KEY;
    this.projectId = projectId != null ? projectId : process.env.BROWSERBASE_PROJECT_ID;
    this.verbose = verbose != null ? verbose : 0;
    this.debugDom = debugDom != null ? debugDom : false;
    this.defaultModelName = "gpt-4o";
    this.domSettleTimeoutMs = domSettleTimeoutMs != null ? domSettleTimeoutMs : 3e4;
    this.headless = headless != null ? headless : false;
    this.browserBaseSessionCreateParams = browserBaseSessionCreateParams;
    this.actHandler = new StagehandActHandler({
      stagehand: this,
      verbose: this.verbose,
      llmProvider: this.llmProvider,
      enableCaching: this.enableCaching,
      logger: this.logger,
      waitForSettledDom: this._waitForSettledDom.bind(this),
      defaultModelName: this.defaultModelName,
      startDomDebug: this.startDomDebug.bind(this),
      cleanupDomDebug: this.cleanupDomDebug.bind(this)
    });
    this.browserbaseResumeSessionID = browserbaseResumeSessionID;
  }
  init() {
    return __async(this, arguments, function* ({
      modelName = "gpt-4o",
      domSettleTimeoutMs
    } = {}) {
      const { context, debugUrl, sessionUrl } = yield getBrowser(
        this.apiKey,
        this.projectId,
        this.env,
        this.headless,
        this.logger,
        this.browserBaseSessionCreateParams,
        this.browserbaseResumeSessionID
      ).catch((e) => {
        console.error("Error in init:", e);
        return { context: void 0, debugUrl: void 0, sessionUrl: void 0 };
      });
      this.context = context;
      this.page = context.pages()[0];
      yield this.page.waitForLoadState("domcontentloaded");
      yield this._waitForSettledDom();
      this.defaultModelName = modelName;
      this.domSettleTimeoutMs = domSettleTimeoutMs != null ? domSettleTimeoutMs : this.domSettleTimeoutMs;
      const originalGoto = this.page.goto.bind(this.page);
      this.page.goto = (url, options) => __async(this, null, function* () {
        const result = yield originalGoto(url, options);
        yield this.page.waitForLoadState("domcontentloaded");
        yield this._waitForSettledDom();
        return result;
      });
      if (this.headless) {
        yield this.page.setViewportSize({ width: 1280, height: 720 });
      }
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "xpathUtils.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "xpathUtils.js"),
          "utf8"
        )
      });
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "process.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "process.js"),
          "utf8"
        )
      });
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "utils.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "utils.js"),
          "utf8"
        )
      });
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "debug.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "debug.js"),
          "utf8"
        )
      });
      return { debugUrl, sessionUrl };
    });
  }
  initFromPage(page, modelName) {
    return __async(this, null, function* () {
      this.page = page;
      this.context = page.context();
      this.defaultModelName = modelName || this.defaultModelName;
      const originalGoto = this.page.goto.bind(this.page);
      this.page.goto = (url, options) => __async(this, null, function* () {
        const result = yield originalGoto(url, options);
        yield this.page.waitForLoadState("domcontentloaded");
        yield this._waitForSettledDom();
        return result;
      });
      if (this.headless) {
        yield this.page.setViewportSize({ width: 1280, height: 720 });
      }
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "xpathUtils.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "xpathUtils.js"),
          "utf8"
        )
      });
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "process.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "process.js"),
          "utf8"
        )
      });
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "utils.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "utils.js"),
          "utf8"
        )
      });
      yield this.context.addInitScript({
        path: import_path2.default.join(__dirname, "..", "dist", "dom", "build", "debug.js"),
        content: import_fs2.default.readFileSync(
          import_path2.default.join(__dirname, "..", "dist", "dom", "build", "debug.js"),
          "utf8"
        )
      });
      return { context: this.context };
    });
  }
  log({
    message,
    category,
    level
  }) {
    const logObj = { category, message, level };
    logObj.level = logObj.level || 1;
    if (this.externalLogger) {
      this.externalLogger(logObj);
    } else {
      const categoryString = logObj.category ? `:${logObj.category}` : "";
      const logMessage = `[stagehand${categoryString}] ${logObj.message}`;
      console.log(logMessage);
    }
    this.pending_logs_to_send_to_browserbase.push(__spreadProps(__spreadValues({}, logObj), {
      id: Math.random().toString(36).substring(2, 15)
    }));
    this._run_browserbase_log_processing_cycle();
  }
  _run_browserbase_log_processing_cycle() {
    return __async(this, null, function* () {
      if (this.is_processing_browserbase_logs) {
        return;
      }
      this.is_processing_browserbase_logs = true;
      const pending_logs = [...this.pending_logs_to_send_to_browserbase];
      for (const logObj of pending_logs) {
        yield this._log_to_browserbase(logObj);
      }
      this.is_processing_browserbase_logs = false;
    });
  }
  _log_to_browserbase(logObj) {
    return __async(this, null, function* () {
      logObj.level = logObj.level || 1;
      if (!this.page) {
        return;
      }
      if (this.verbose >= logObj.level) {
        yield this.page.evaluate((logObj2) => {
          const logMessage = `[stagehand${logObj2.category ? `:${logObj2.category}` : ""}] ${logObj2.message}`;
          if (logObj2.message.toLowerCase().includes("trace") || logObj2.message.toLowerCase().includes("error:")) {
            console.error(logMessage);
          } else {
            console.log(logMessage);
          }
        }, logObj).then(() => {
          this.pending_logs_to_send_to_browserbase = this.pending_logs_to_send_to_browserbase.filter(
            (log) => log.id !== logObj.id
          );
        }).catch((e) => {
        });
      }
    });
  }
  _waitForSettledDom(timeoutMs) {
    return __async(this, null, function* () {
      try {
        const timeout = timeoutMs != null ? timeoutMs : this.domSettleTimeoutMs;
        let timeoutHandle;
        const timeoutPromise = new Promise((resolve, reject) => {
          timeoutHandle = setTimeout(() => {
            this.log({
              category: "dom",
              message: `DOM settle timeout of ${timeout}ms exceeded, continuing anyway`,
              level: 1
            });
            resolve();
          }, timeout);
        });
        try {
          yield Promise.race([
            this.page.evaluate(() => {
              return new Promise((resolve) => {
                if (typeof window.waitForDomSettle === "function") {
                  window.waitForDomSettle().then(resolve);
                } else {
                  console.warn(
                    "waitForDomSettle is not defined, considering DOM as settled"
                  );
                  resolve();
                }
              });
            }),
            this.page.waitForLoadState("domcontentloaded"),
            this.page.waitForSelector("body"),
            timeoutPromise
          ]);
        } finally {
          clearTimeout(timeoutHandle);
        }
      } catch (e) {
        this.log({
          category: "dom",
          message: `Error in waitForSettledDom: ${e.message}
Trace: ${e.stack}`,
          level: 1
        });
      }
    });
  }
  startDomDebug() {
    return __async(this, null, function* () {
      try {
        yield this.page.evaluate(() => {
          if (typeof window.debugDom === "function") {
            window.debugDom();
          } else {
            this.log({
              category: "dom",
              message: "debugDom is not defined",
              level: 1
            });
          }
        }).catch(() => {
        });
      } catch (e) {
        this.log({
          category: "dom",
          message: `Error in startDomDebug: ${e.message}
Trace: ${e.stack}`,
          level: 1
        });
      }
    });
  }
  cleanupDomDebug() {
    return __async(this, null, function* () {
      if (this.debugDom) {
        yield this.page.evaluate(() => window.cleanupDebug()).catch(() => {
        });
      }
    });
  }
  _recordObservation(instruction, result) {
    return __async(this, null, function* () {
      const id = generateId(instruction);
      this.observations[id] = { result, instruction };
      return id;
    });
  }
  // Main methods
  _extract(_0) {
    return __async(this, arguments, function* ({
      instruction,
      schema,
      progress = "",
      content = {},
      chunksSeen = [],
      modelName,
      requestId,
      domSettleTimeoutMs
    }) {
      this.log({
        category: "extraction",
        message: `starting extraction '${instruction}'`,
        level: 1
      });
      yield this._waitForSettledDom(domSettleTimeoutMs);
      yield this.startDomDebug();
      const { outputString, chunk, chunks } = yield this.page.evaluate(
        (chunksSeen2) => window.processDom(chunksSeen2 != null ? chunksSeen2 : []),
        chunksSeen
      );
      this.log({
        category: "extraction",
        message: `received output from processDom. Current chunk index: ${chunk}, Number of chunks left: ${chunks.length - chunksSeen.length}`,
        level: 1
      });
      const extractionResponse = yield extract({
        instruction,
        progress,
        previouslyExtractedContent: content,
        domElements: outputString,
        llmProvider: this.llmProvider,
        schema,
        modelName: modelName || this.defaultModelName,
        chunksSeen: chunksSeen.length,
        chunksTotal: chunks.length,
        requestId
      });
      const _a = extractionResponse, {
        metadata: { progress: newProgress, completed }
      } = _a, output = __objRest(_a, [
        "metadata"
      ]);
      yield this.cleanupDomDebug();
      this.log({
        category: "extraction",
        message: `received extraction response: ${JSON.stringify(extractionResponse)}`,
        level: 1
      });
      chunksSeen.push(chunk);
      if (completed || chunksSeen.length === chunks.length) {
        this.log({
          category: "extraction",
          message: `response: ${JSON.stringify(extractionResponse)}`,
          level: 1
        });
        return output;
      } else {
        this.log({
          category: "extraction",
          message: `continuing extraction, progress: '${newProgress}'`,
          level: 1
        });
        yield this._waitForSettledDom(domSettleTimeoutMs);
        return this._extract({
          instruction,
          schema,
          progress: newProgress,
          content: output,
          chunksSeen,
          modelName,
          domSettleTimeoutMs
        });
      }
    });
  }
  _observe(_0) {
    return __async(this, arguments, function* ({
      instruction,
      useVision,
      fullPage,
      modelName,
      requestId,
      domSettleTimeoutMs
    }) {
      if (!instruction) {
        instruction = `Find elements that can be used for any future actions in the page. These may be navigation links, related pages, section/subsection links, buttons, or other interactive elements. Be comprehensive: if there are multiple elements that may be relevant for future actions, return all of them.`;
      }
      const model = modelName != null ? modelName : this.defaultModelName;
      this.log({
        category: "observation",
        message: `starting observation: ${instruction}`,
        level: 1
      });
      yield this._waitForSettledDom(domSettleTimeoutMs);
      yield this.startDomDebug();
      let { outputString, selectorMap } = yield this.page.evaluate(
        (fullPage2) => fullPage2 ? window.processAllOfDom() : window.processDom([]),
        fullPage
      );
      let annotatedScreenshot;
      if (useVision === true) {
        if (!modelsWithVision.includes(model)) {
          this.log({
            category: "observation",
            message: `${model} does not support vision. Skipping vision processing.`,
            level: 1
          });
        } else {
          const screenshotService = new ScreenshotService(
            this.page,
            selectorMap,
            this.verbose
          );
          annotatedScreenshot = yield screenshotService.getAnnotatedScreenshot(fullPage);
          outputString = "n/a. use the image to find the elements.";
        }
      }
      const observationResponse = yield observe({
        instruction,
        domElements: outputString,
        llmProvider: this.llmProvider,
        modelName: modelName || this.defaultModelName,
        image: annotatedScreenshot,
        requestId
      });
      const elementsWithSelectors = observationResponse.elements.map(
        (element) => {
          const _a = element, { elementId } = _a, rest = __objRest(_a, ["elementId"]);
          return __spreadProps(__spreadValues({}, rest), {
            selector: `xpath=${selectorMap[elementId][0]}`
          });
        }
      );
      yield this.cleanupDomDebug();
      this._recordObservation(instruction, elementsWithSelectors);
      this.log({
        category: "observation",
        message: `found element ${JSON.stringify(elementsWithSelectors)}`,
        level: 1
      });
      yield this._recordObservation(instruction, elementsWithSelectors);
      return elementsWithSelectors;
    });
  }
  act(_0) {
    return __async(this, arguments, function* ({
      action,
      modelName,
      useVision = "fallback",
      variables = {},
      domSettleTimeoutMs
    }) {
      useVision = useVision != null ? useVision : "fallback";
      const requestId = Math.random().toString(36).substring(2);
      this.logger({
        category: "act",
        message: `Running act with action: ${action}, requestId: ${requestId}`
      });
      if (variables) {
        this.variables = __spreadValues(__spreadValues({}, this.variables), variables);
      }
      return this.actHandler.act({
        action,
        modelName,
        chunksSeen: [],
        useVision,
        verifierUseVision: useVision !== false,
        requestId,
        variables,
        previousSelectors: [],
        skipActionCacheForThisStep: false,
        domSettleTimeoutMs
      }).catch((e) => {
        this.logger({
          category: "act",
          message: `Error acting: ${e.message}
Trace: ${e.stack}`
        });
        return {
          success: false,
          message: `Internal error: Error acting: ${e.message}`,
          action
        };
      });
    });
  }
  extract(_0) {
    return __async(this, arguments, function* ({
      instruction,
      schema,
      modelName,
      domSettleTimeoutMs
    }) {
      const requestId = Math.random().toString(36).substring(2);
      this.logger({
        category: "extract",
        message: `Running extract with instruction: ${instruction}, requestId: ${requestId}`
      });
      return this._extract({
        instruction,
        schema,
        modelName,
        requestId,
        domSettleTimeoutMs
      }).catch((e) => {
        this.logger({
          category: "extract",
          message: `Internal error: Error extracting: ${e.message}
Trace: ${e.stack}`
        });
        if (this.enableCaching) {
          this.llmProvider.cleanRequestCache(requestId);
        }
        throw e;
      });
    });
  }
  observe(options) {
    return __async(this, null, function* () {
      var _a, _b;
      const requestId = Math.random().toString(36).substring(2);
      this.logger({
        category: "observe",
        message: `Running observe with instruction: ${options == null ? void 0 : options.instruction}, requestId: ${requestId}`
      });
      return this._observe({
        instruction: (_a = options == null ? void 0 : options.instruction) != null ? _a : "Find actions that can be performed on this page.",
        modelName: options == null ? void 0 : options.modelName,
        useVision: (_b = options == null ? void 0 : options.useVision) != null ? _b : false,
        fullPage: false,
        requestId,
        domSettleTimeoutMs: options == null ? void 0 : options.domSettleTimeoutMs
      }).catch((e) => {
        this.logger({
          category: "observe",
          message: `Error observing: ${e.message}
Trace: ${e.stack}`
        });
        if (this.enableCaching) {
          this.llmProvider.cleanRequestCache(requestId);
        }
        throw e;
      });
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Stagehand
});
